<!DOCTYPE html><html lang="en"><head><title>clCommandQueue</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="clCommandQueue"><meta name="groc-project-path" content="lib/clCommandQueue.js"><meta name="groc-github-url" content="https://github.com/unbornchikken/NOOOCL"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/unbornchikken/NOOOCL/blob/master/lib/clCommandQueue.js">lib/clCommandQueue.js</a></div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> CLWrapper = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./clWrapper'</span>);
<span class="hljs-keyword">var</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>);
<span class="hljs-keyword">var</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash'</span>);
<span class="hljs-keyword">var</span> ref = <span class="hljs-built_in">require</span>(<span class="hljs-string">'ref'</span>);
<span class="hljs-keyword">var</span> Promise = <span class="hljs-built_in">require</span>(<span class="hljs-string">'bluebird'</span>);
<span class="hljs-keyword">var</span> CLEvent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./clEvent'</span>);
<span class="hljs-keyword">var</span> CLContext = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./clContext'</span>);
<span class="hljs-keyword">var</span> CLDevice = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./clDevice'</span>);
<span class="hljs-keyword">var</span> NDRange = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./ndRange'</span>);
<span class="hljs-keyword">var</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">'assert'</span>);
<span class="hljs-keyword">var</span> clUtils = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./clUtils'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CLCommandQueue</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &gt;= <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> CLContext &amp;&amp; <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] <span class="hljs-keyword">instanceof</span> CLDevice) {
        CLCommandQueue2.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    }
    <span class="hljs-keyword">else</span> {
        CLCommandQueue1.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    }
    <span class="hljs-keyword">this</span>.isWaitable = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>._notWaitableVersion = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">this</span>._waitableVersion = <span class="hljs-literal">null</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CLCommandQueue1</span><span class="hljs-params">(cl, handle)</span> </span>{
    CLWrapper.call(<span class="hljs-keyword">this</span>, cl, handle);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CLCommandQueue2</span><span class="hljs-params">(context, device, outOfOrder, profiling)</span> </span>{
    <span class="hljs-keyword">var</span> cl = context.cl;
    outOfOrder = _.isBoolean(outOfOrder) ? outOfOrder : <span class="hljs-literal">false</span>;
    profiling = _.isBoolean(profiling) ? profiling : <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> err = ref.alloc(cl.types.ErrorCode);

    <span class="hljs-keyword">var</span> handle = cl.imports.clCreateCommandQueue(
        clUtils.toHandle(context),
        clUtils.toHandle(device),
        (outOfOrder ? cl.defs.CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE : <span class="hljs-number">0</span>) | (profiling ? cl.defs.CL_QUEUE_PROFILING_ENABLE : <span class="hljs-number">0</span>),
        err);
    cl.checkError(err);

    CLWrapper.call(<span class="hljs-keyword">this</span>, cl, handle);
}

util.inherits(CLCommandQueue, CLWrapper);

<span class="hljs-built_in">Object</span>.defineProperties(CLCommandQueue.prototype, {
    _classInfoFunction: {
        get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-string">'clGetCommandQueueInfo'</span>;
        }
    },
    context: {
        get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">this</span>._throwIfReleased();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CLContext(<span class="hljs-keyword">this</span>.cl, <span class="hljs-keyword">this</span>._getInfo(<span class="hljs-keyword">this</span>.cl.types.Context, <span class="hljs-keyword">this</span>.cl.defs.CL_QUEUE_CONTEXT));
        }
    },
    device: {
        get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">this</span>._throwIfReleased();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CLDevice(<span class="hljs-keyword">this</span>.cl, <span class="hljs-keyword">this</span>._getInfo(<span class="hljs-keyword">this</span>.cl.types.DeviceId, <span class="hljs-keyword">this</span>.cl.defs.CL_QUEUE_DEVICE));
        }
    },
    properties: {
        get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">this</span>._throwIfReleased();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._getInfo(<span class="hljs-keyword">this</span>.cl.types.CommandQueueProperties, <span class="hljs-keyword">this</span>.cl.defs.CL_QUEUE_PROPERTIES);
        }
    },
    isOutOfOrder: {
        get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">this</span>._throwIfReleased();
            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.properties &amp; <span class="hljs-keyword">this</span>.cl.defs.CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;
        }
    },
    isProfilingEnabled: {
        get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">this</span>._throwIfReleased();
            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.properties &amp; <span class="hljs-keyword">this</span>.cl.defs.CL_QUEUE_PROFILING_ENABLE) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;
        }
    },
    waitableVersion: {
        get: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">this</span>._throwIfReleased();
            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._waitableVersion) {
                <span class="hljs-keyword">var</span> err = <span class="hljs-keyword">this</span>.cl.imports.clRetainCommandQueue(<span class="hljs-keyword">this</span>.handle);
                <span class="hljs-keyword">this</span>.cl.checkError(err);
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-keyword">var</span> newQueue = <span class="hljs-keyword">new</span> CLCommandQueue(<span class="hljs-keyword">this</span>.cl, <span class="hljs-keyword">this</span>.handle);
                    newQueue.isWaitable = <span class="hljs-literal">true</span>;
                    newQueue._notWaitableVersion = <span class="hljs-keyword">this</span>;
                    newQueue._waitableVersion = newQueue;
                    <span class="hljs-keyword">this</span>._waitableVersion = newQueue;
                }
                <span class="hljs-keyword">catch</span> (e) {
                    <span class="hljs-keyword">this</span>.cl.imports.clReleaseCommandQueue(<span class="hljs-keyword">this</span>.handle);
                    <span class="hljs-keyword">throw</span> e;
                }
            }
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._waitableVersion;
        }
    },
    notWaitableVersion: {
        get: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">this</span>._throwIfReleased();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._notWaitableVersion;
        }
    }
});

CLCommandQueue.prototype.createReleaseMethod = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">var</span> handle = <span class="hljs-keyword">this</span>.handle;
    <span class="hljs-keyword">var</span> cl = <span class="hljs-keyword">this</span>.cl;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        cl.imports.clReleaseCommandQueue(handle);
    };
};

CLCommandQueue.prototype.waitable = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> </span>{
    value = (value || <span class="hljs-literal">true</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isWaitable === value) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> value ? <span class="hljs-keyword">this</span>.waitableVersion : <span class="hljs-keyword">this</span>.notWaitableVersion;
};

CLCommandQueue.prototype.flush = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">this</span>._throwIfReleased();
    <span class="hljs-keyword">var</span> err = <span class="hljs-keyword">this</span>.cl.imports.clFlush(<span class="hljs-keyword">this</span>.handle);
    <span class="hljs-keyword">this</span>.cl.checkError(err);
};

CLCommandQueue.prototype.enqueueWaitForEvents = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(events)</span> </span>{
    <span class="hljs-keyword">this</span>._throwIfReleased();
    <span class="hljs-keyword">if</span> (!events.length) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> waitList = toWaitList(events);
    <span class="hljs-keyword">var</span> err = <span class="hljs-keyword">this</span>.cl.imports.clEnqueueWaitForEvents(<span class="hljs-keyword">this</span>.handle, waitList.count, waitList.array);
    <span class="hljs-keyword">this</span>.cl.checkError(err);
};

CLCommandQueue.prototype.enqueueTask = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(kernel, events)</span> </span>{
    <span class="hljs-keyword">this</span>._throwIfReleased();
    <span class="hljs-keyword">var</span> event = <span class="hljs-keyword">this</span>.isWaitable ? ref.alloc(<span class="hljs-keyword">this</span>.cl.types.Event) : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> waitList = toWaitList(events);
    <span class="hljs-keyword">var</span> err = <span class="hljs-keyword">this</span>.cl.imports.clEnqueueTask(<span class="hljs-keyword">this</span>.handle, clUtils.toHandle(kernel), waitList.count, waitList.array, event);
    <span class="hljs-keyword">this</span>.cl.checkError(err);
    <span class="hljs-keyword">if</span> (event) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CLEvent(<span class="hljs-keyword">this</span>.cl, event.deref());
};

CLCommandQueue.prototype.enqueueMarker = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">this</span>._throwIfReleased();
    <span class="hljs-keyword">var</span> event = ref.alloc(<span class="hljs-keyword">this</span>.cl.types.Event);
    <span class="hljs-keyword">var</span> err = <span class="hljs-keyword">this</span>.cl.imports.clEnqueueMarker(<span class="hljs-keyword">this</span>.handle, event);
    <span class="hljs-keyword">this</span>.cl.checkError(err);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CLEvent(<span class="hljs-keyword">this</span>.cl, event.deref());
};

CLCommandQueue.prototype.enqueueBarrier = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">this</span>._throwIfReleased();
    <span class="hljs-keyword">var</span> err = <span class="hljs-keyword">this</span>.cl.imports.clEnqueueBarrier(<span class="hljs-keyword">this</span>.handle);
    <span class="hljs-keyword">this</span>.cl.checkError(err);
};

CLCommandQueue.prototype.enqueueNDRangeKernel = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(kernel, globalRange, localRange, offset, events)</span> </span>{
    <span class="hljs-keyword">this</span>._throwIfReleased();
    globalRange = globalRange || NDRange.nullRange;
    localRange = localRange || NDRange.nullRange;
    offset = offset || NDRange.nullRange;
    <span class="hljs-keyword">var</span> event = <span class="hljs-keyword">this</span>.isWaitable ? ref.alloc(<span class="hljs-keyword">this</span>.cl.types.Event) : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> waitList = toWaitList(events);
    <span class="hljs-keyword">var</span> err = <span class="hljs-keyword">this</span>.cl.imports.clEnqueueNDRangeKernel(<span class="hljs-keyword">this</span>.handle, clUtils.toHandle(kernel), globalRange.dimensions, offset.sizes, globalRange.sizes, localRange.sizes, waitList.count, waitList.array, event);
    <span class="hljs-keyword">this</span>.cl.checkError(err);
    <span class="hljs-keyword">if</span> (event) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CLEvent(<span class="hljs-keyword">this</span>.cl, event.deref());
};

CLCommandQueue.prototype._enqueueReadWriteBuffer = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(func, buffer, offset, size, ptr, events)</span> </span>{
    <span class="hljs-keyword">this</span>._throwIfReleased();
    <span class="hljs-keyword">var</span> event = <span class="hljs-keyword">this</span>.isWaitable ? ref.alloc(<span class="hljs-keyword">this</span>.cl.types.Event) : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> waitList = toWaitList(events);
    <span class="hljs-keyword">var</span> err = func(<span class="hljs-keyword">this</span>.handle, clUtils.toHandle(buffer), <span class="hljs-literal">false</span>, offset, size, clUtils.toPtr(ptr), waitList.count, waitList.array, event);
    <span class="hljs-keyword">this</span>.cl.checkError(err);
    <span class="hljs-keyword">if</span> (event) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CLEvent(<span class="hljs-keyword">this</span>.cl, event.deref());
};

CLCommandQueue.prototype.enqueueReadBuffer = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(buffer, offset, size, ptr, events)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._enqueueReadWriteBuffer(<span class="hljs-keyword">this</span>.cl.imports.clEnqueueReadBuffer, buffer, offset, size, ptr, events);
};

CLCommandQueue.prototype.enqueueWriteBuffer = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(buffer, offset, size, ptr, events)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._enqueueReadWriteBuffer(<span class="hljs-keyword">this</span>.cl.imports.clEnqueueWriteBuffer, buffer, offset, size, ptr, events);
};

CLCommandQueue.prototype.enqueueMapBuffer = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(buffer, flags, offset, size, out, events)</span> </span>{
    <span class="hljs-keyword">this</span>._throwIfReleased();
    assert(_.isObject(out), <span class="hljs-string">'Out must be an object.'</span>);
    <span class="hljs-keyword">var</span> event = <span class="hljs-keyword">this</span>.isWaitable ? ref.alloc(<span class="hljs-keyword">this</span>.cl.types.Event) : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> waitList = toWaitList(events);
    <span class="hljs-keyword">var</span> err = ref.alloc(<span class="hljs-keyword">this</span>.cl.types.ErrorCode);
    <span class="hljs-keyword">var</span> ptr = <span class="hljs-keyword">this</span>.cl.imports.clEnqueueMapBuffer(<span class="hljs-keyword">this</span>.handle, clUtils.toHandle(buffer), <span class="hljs-literal">false</span>, flags, offset, size, waitList.count, waitList.array, event, err);
    <span class="hljs-keyword">this</span>.cl.checkError(err);
    out.ptr = ptr;
    <span class="hljs-keyword">if</span> (event) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CLEvent(<span class="hljs-keyword">this</span>.cl, event.deref());
};

CLCommandQueue.prototype.enqueueMapImage = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(image, flags, origin, region, out, events)</span> </span>{
    <span class="hljs-keyword">this</span>._throwIfReleased();
    assert(_.isObject(out), <span class="hljs-string">'Out must be an object.'</span>);
    <span class="hljs-keyword">var</span> event = <span class="hljs-keyword">this</span>.isWaitable ? ref.alloc(<span class="hljs-keyword">this</span>.cl.types.Event) : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> waitList = toWaitList(events);
    <span class="hljs-keyword">var</span> err = ref.alloc(<span class="hljs-keyword">this</span>.cl.types.ErrorCode);
    <span class="hljs-keyword">var</span> rowPitch = ref.alloc(<span class="hljs-string">'size_t'</span>);
    <span class="hljs-keyword">var</span> slicePitch = ref.alloc(<span class="hljs-string">'size_t'</span>);
    <span class="hljs-keyword">var</span> ptr = <span class="hljs-keyword">this</span>.cl.imports.clEnqueueMapImage(<span class="hljs-keyword">this</span>.handle, clUtils.toHandle(image), <span class="hljs-literal">false</span>, flags, origin.sizes, region.sizes, rowPitch, slicePitch, waitList.count, waitList.array, event, err);
    <span class="hljs-keyword">this</span>.cl.checkError(err);
    out.ptr = ptr;
    out.rowPitch = rowPitch.deref();
    out.slicePitch = slicePitch.deref();
    <span class="hljs-keyword">if</span> (event) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CLEvent(<span class="hljs-keyword">this</span>.cl, event.deref());
};

CLCommandQueue.prototype.enqueueUnmapMemory = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(memory, ptr, events)</span> </span>{
    <span class="hljs-keyword">this</span>._throwIfReleased();
    <span class="hljs-keyword">var</span> event = <span class="hljs-keyword">this</span>.isWaitable ? ref.alloc(<span class="hljs-keyword">this</span>.cl.types.Event) : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> waitList = toWaitList(events);
    <span class="hljs-keyword">var</span> err = <span class="hljs-keyword">this</span>.cl.imports.clEnqueueUnmapMemObject(<span class="hljs-keyword">this</span>.handle, clUtils.toHandle(memory), ptr, waitList.count, waitList.array, event);
    <span class="hljs-keyword">this</span>.cl.checkError(err);
    <span class="hljs-keyword">if</span> (event) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CLEvent(<span class="hljs-keyword">this</span>.cl, event.deref());
};

CLCommandQueue.prototype.enqueueAcquireGLObjects = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">this</span>._throwIfReleased();
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'TODO'</span>);
};

CLCommandQueue.prototype.enqueueReleaseGLObjects = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">this</span>._throwIfReleased();
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'TODO'</span>);
};

CLCommandQueue.prototype._enqueueReadWriteImage = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(func, image, origin, region, ptr, rowPitch, slicePitch, events)</span> </span>{
    <span class="hljs-keyword">this</span>._throwIfReleased();
    rowPitch = rowPitch || <span class="hljs-number">0</span>;
    slicePitch = slicePitch || <span class="hljs-number">0</span>;

    <span class="hljs-keyword">var</span> event = <span class="hljs-keyword">this</span>.isWaitable ? ref.alloc(<span class="hljs-keyword">this</span>.cl.types.Event) : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> waitList = toWaitList(events);
    <span class="hljs-keyword">var</span> err = func(<span class="hljs-keyword">this</span>.handle, clUtils.toHandle(image), <span class="hljs-literal">false</span>, origin.sizes, region.sizes, rowPitch, slicePitch, clUtils.toPtr(ptr), waitList.count, waitList.array, event);
    <span class="hljs-keyword">this</span>.cl.checkError(err);
    <span class="hljs-keyword">if</span> (event) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CLEvent(<span class="hljs-keyword">this</span>.cl, event.deref());
};

CLCommandQueue.prototype.enqueueReadImage = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(image, origin, region, ptr, rowPitch, slicePitch, events)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._enqueueReadWriteImage(<span class="hljs-keyword">this</span>.cl.imports.clEnqueueReadImage, image, origin, region, ptr, rowPitch, slicePitch, events);
};

CLCommandQueue.prototype.enqueueWriteImage = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(image, origin, region, ptr, rowPitch, slicePitch, events)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._enqueueReadWriteImage(<span class="hljs-keyword">this</span>.cl.imports.clEnqueueWriteImage, image, origin, region, ptr, rowPitch, slicePitch, events);
};

CLCommandQueue.prototype.enqueueCopyBuffer = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(srcBuffer, dstBuffer, srcOffset, dstOffset, size, events)</span> </span>{
    <span class="hljs-keyword">this</span>._throwIfReleased();
    <span class="hljs-keyword">var</span> event = <span class="hljs-keyword">this</span>.isWaitable ? ref.alloc(<span class="hljs-keyword">this</span>.cl.types.Event) : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> waitList = toWaitList(events);
    <span class="hljs-keyword">var</span> err = <span class="hljs-keyword">this</span>.cl.imports.clEnqueueCopyBuffer(<span class="hljs-keyword">this</span>.handle, clUtils.toHandle(srcBuffer), clUtils.toHandle(dstBuffer), srcOffset, dstOffset, size, waitList.count, waitList.array, event);
    <span class="hljs-keyword">this</span>.cl.checkError(err);
    <span class="hljs-keyword">if</span> (event) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CLEvent(<span class="hljs-keyword">this</span>.cl, event.deref());
};

CLCommandQueue.prototype.enqueueCopyImage = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(srcImage, dstImage, srcOrigin, dstOrigin, region, events)</span> </span>{
    <span class="hljs-keyword">this</span>._throwIfReleased();
    <span class="hljs-keyword">var</span> event = <span class="hljs-keyword">this</span>.isWaitable ? ref.alloc(<span class="hljs-keyword">this</span>.cl.types.Event) : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> waitList = toWaitList(events);
    <span class="hljs-keyword">var</span> err = <span class="hljs-keyword">this</span>.cl.imports.clEnqueueCopyImage(<span class="hljs-keyword">this</span>.handle, clUtils.toHandle(srcImage), clUtils.toHandle(dstImage), srcOrigin.sizes, dstOrigin.sizes, region.sizes, waitList.count, waitList.array, event);
    <span class="hljs-keyword">this</span>.cl.checkError(err);
    <span class="hljs-keyword">if</span> (event) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CLEvent(<span class="hljs-keyword">this</span>.cl, event.deref());
};

CLCommandQueue.prototype.enqueueCopyImageToBuffer = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(srcImage, dstBuffer, srcOrigin, region, dstOffset, events)</span> </span>{
    <span class="hljs-keyword">this</span>._throwIfReleased();
    <span class="hljs-keyword">var</span> event = <span class="hljs-keyword">this</span>.isWaitable ? ref.alloc(<span class="hljs-keyword">this</span>.cl.types.Event) : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> waitList = toWaitList(events);
    <span class="hljs-keyword">var</span> err = <span class="hljs-keyword">this</span>.cl.imports.clEnqueueCopyImageToBuffer(<span class="hljs-keyword">this</span>.handle, clUtils.toHandle(srcImage), clUtils.toHandle(dstBuffer), srcOrigin.sizes, region.sizes, dstOffset, waitList.count, waitList.array, event);
    <span class="hljs-keyword">this</span>.cl.checkError(err);
    <span class="hljs-keyword">if</span> (event) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CLEvent(<span class="hljs-keyword">this</span>.cl, event.deref());
};

CLCommandQueue.prototype.enqueueCopyBufferToImage = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(srcBuffer, dstImage, srcOffset, dstOrigin, region, events)</span> </span>{
    <span class="hljs-keyword">this</span>._throwIfReleased();
    <span class="hljs-keyword">var</span> event = <span class="hljs-keyword">this</span>.isWaitable ? ref.alloc(<span class="hljs-keyword">this</span>.cl.types.Event) : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> waitList = toWaitList(events);
    <span class="hljs-keyword">var</span> err = <span class="hljs-keyword">this</span>.cl.imports.clEnqueueCopyImageToBuffer(<span class="hljs-keyword">this</span>.handle, clUtils.toHandle(srcBuffer), clUtils.toHandle(dstImage), srcOffset, dstOrigin.sizes, region.sizes, waitList.count, waitList.array, event);
    <span class="hljs-keyword">this</span>.cl.checkError(err);
    <span class="hljs-keyword">if</span> (event) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CLEvent(<span class="hljs-keyword">this</span>.cl, event.deref());
};

CLCommandQueue.prototype._enqueueReadWriteBufferRect = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(func, buffer, bufferOrigin, hostOrigin, region, ptr, bufferRowPitch, bufferSlicePitch, hostRowPitch, hostSlicePitch, events)</span> </span>{
    <span class="hljs-keyword">this</span>._throwIfReleased();

    bufferRowPitch = bufferRowPitch || <span class="hljs-number">0</span>;
    bufferSlicePitch = bufferSlicePitch || <span class="hljs-number">0</span>;
    hostRowPitch = hostRowPitch || <span class="hljs-number">0</span>;
    hostSlicePitch = hostSlicePitch || <span class="hljs-number">0</span>;

    <span class="hljs-keyword">var</span> event = <span class="hljs-keyword">this</span>.isWaitable ? ref.alloc(<span class="hljs-keyword">this</span>.cl.types.Event) : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> waitList = toWaitList(events);
    <span class="hljs-keyword">var</span> err = func(<span class="hljs-keyword">this</span>.handle, clUtils.toHandle(buffer), <span class="hljs-literal">false</span>, bufferOrigin.sizes, hostOrigin.sizes, region.sizes, bufferRowPitch, bufferSlicePitch, hostRowPitch, hostSlicePitch, clUtils.toPtr(ptr), waitList.count, waitList.array, event);
    <span class="hljs-keyword">this</span>.cl.checkError(err);
    <span class="hljs-keyword">if</span> (event) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CLEvent(<span class="hljs-keyword">this</span>.cl, event.deref());
};

CLCommandQueue.prototype.enqueueReadBufferRect = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(buffer, bufferOrigin, hostOrigin, region, ptr, bufferRowPitch, bufferSlicePitch, hostRowPitch, hostSlicePitch, events)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._enqueueReadWriteBufferRect(<span class="hljs-keyword">this</span>.cl.imports.clEnqueueReadBufferRect, buffer, bufferOrigin, hostOrigin, region, ptr, bufferRowPitch, bufferSlicePitch, hostRowPitch, hostSlicePitch, events);
};

CLCommandQueue.prototype.enqueueWriteBufferRect = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(buffer, bufferOrigin, hostOrigin, region, ptr, bufferRowPitch, bufferSlicePitch, hostRowPitch, hostSlicePitch, events)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._enqueueReadWriteBufferRect(<span class="hljs-keyword">this</span>.cl.imports.clEnqueueWriteBufferRect, buffer, bufferOrigin, hostOrigin, region, ptr, bufferRowPitch, bufferSlicePitch, hostRowPitch, hostSlicePitch, events);
};

CLCommandQueue.prototype.enqueueCopyBufferRect = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(srcBuffer, dstBuffer, srcOrigin, dstOrigin, region, srcRowPitch, srcSlicePitch, dstRowPitch, dstSlicePitch, events)</span> </span>{
    <span class="hljs-keyword">this</span>._throwIfReleased();

    srcRowPitch = srcRowPitch || <span class="hljs-number">0</span>;
    srcSlicePitch = srcSlicePitch || <span class="hljs-number">0</span>;
    dstRowPitch = dstRowPitch || <span class="hljs-number">0</span>;
    dstSlicePitch = dstSlicePitch || <span class="hljs-number">0</span>;

    <span class="hljs-keyword">var</span> event = <span class="hljs-keyword">this</span>.isWaitable ? ref.alloc(<span class="hljs-keyword">this</span>.cl.types.Event) : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> waitList = toWaitList(events);
    <span class="hljs-keyword">var</span> err = <span class="hljs-keyword">this</span>.cl.imports.clEnqueueCopyBufferRect(<span class="hljs-keyword">this</span>.handle, clUtils.toHandle(srcBuffer), clUtils.toHandle(dstBuffer), srcOrigin.sizes, dstOrigin.sizes, region.sizes, srcRowPitch, srcSlicePitch, dstRowPitch, dstSlicePitch, waitList.count, waitList.array, event);
    <span class="hljs-keyword">this</span>.cl.checkError(err);
    <span class="hljs-keyword">if</span> (event) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CLEvent(<span class="hljs-keyword">this</span>.cl, event.deref());
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toWaitList</span><span class="hljs-params">(events)</span> </span>{
    <span class="hljs-keyword">if</span> (events &amp;&amp; events.length) {
        <span class="hljs-keyword">var</span> array = <span class="hljs-keyword">new</span> (<span class="hljs-keyword">this</span>.cl.types.EventArray)(events.length);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; events.length; i++) {
            array[i] = clUtils.toHandle(events[i]);
        }
        <span class="hljs-keyword">return</span> {
            count: events.length,
            array: array
        };
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> {
            count: <span class="hljs-number">0</span>,
            array: <span class="hljs-literal">null</span>
        };
    }
}

<span class="hljs-built_in">module</span>.exports = CLCommandQueue;</div></div></div></div></body></html>