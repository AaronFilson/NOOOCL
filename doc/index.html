<!DOCTYPE html><html lang="en"><head><title>index</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="index"><meta name="groc-project-path" content="README.md"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path">README.md</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h1 id="nooocl-mit">NOOOCL (MIT)</h1>
<p>Node.js Object Oriented OpenCL Bindings</p>
<p><a href="https://www.bithound.io/unbornchikken/NOOOCL"><img src="https://www.bithound.io/unbornchikken/NOOOCL/badges/score.svg" alt="bitHound Score"></a></p>
<h2 id="about">About</h2>
<p>This is a full featured OpenCL wrapper library for Node.js. It supports full 1.1 and 1.2 specifications.
Despite it&#39;s an OOP wrapper, <strong>the whole C API available</strong> by <a href="https://www.npmjs.com/package/ffi">ffi</a>, and can be called by using <a href="https://www.npmjs.com/package/ref">ref and co</a>.</p>
<h2 id="install">Install</h2>
<p>NPM:</p>
<pre><code>npm install nooocl</code></pre>
<p>JavaScript:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> nooocl = <span class="hljs-built_in">require</span>(<span class="hljs-string">'nooocl'</span>);
<span class="hljs-keyword">var</span> CLHost = nooocl.CLHost;
<span class="hljs-keyword">var</span> CLPlatform = nooocl.CLPlatform;
<span class="hljs-keyword">var</span> CLDevice = nooocl.CLDevice;
<span class="hljs-keyword">var</span> CLContext = nooocl.CLContext;
<span class="hljs-keyword">var</span> CLBuffer = nooocl.CLBuffer;
<span class="hljs-keyword">var</span> CLCommandQueue = nooocl.CLCommandQueue;
<span class="hljs-keyword">var</span> CLUserEvent = nooocl.CLUserEvent;
<span class="hljs-keyword">var</span> NDRange = nooocl.NDRange;
<span class="hljs-keyword">var</span> CLKernel = nooocl.CLKernel;
<span class="hljs-keyword">var</span> CLImage2D = nooocl.CLImage2D;
<span class="hljs-keyword">var</span> CLImage3D = nooocl.CLImage3D;
<span class="hljs-keyword">var</span> CLSampler = nooocl.CLSampler;</code></pre>
<h2 id="tutorial">Tutorial</h2>
<h3 id="1-basics">1. Basics</h3>
<h4 id="host">Host</h4>
<p>The OpenCL goodness is available through a CLHost instance.</p>
<pre><code class="lang-javascript">host = CLHost.createV11(); <span class="hljs-comment">// for OpenCL 1.1</span>
host = CLHost.createV12(); <span class="hljs-comment">// for OpenCL 1.2</span>
host = <span class="hljs-keyword">new</span> CLHost(<span class="hljs-number">1.1</span>); <span class="hljs-comment">// for OpenCL 1.1</span>
host = <span class="hljs-keyword">new</span> CLHost(<span class="hljs-number">1.2</span>); <span class="hljs-comment">// for OpenCL 1.2</span></code></pre>
<p>we will get an exception if there is no compatible OpenCL platform available.</p>
<p>CLHost and all of CL* class instances share this common, important properties:</p>
<ul>
<li><strong>cl.version</strong>: version of the OpenCL platform</li>
<li><strong>cl.defs.xxx</strong>: predefined OpenCL values, like: CL_MEM_COPY_HOST_PTR, CL_DEVICE_MAX_COMPUTE_UNITS. See the OpenCL specification or <a href="https://github.com/unbornchikken/NOOOCL/blob/master/lib/cl/defs.js">NOOOCL/lib/cl/defs.js</a>.</li>
<li><strong>cl.imports.clxxx</strong>: this is where OpenCL C API is imported with ffi, we can call native API methods like clEnqueueCopyBuffer, clEnqueueNDRangeKernel and co.</li>
<li><strong>cl.types.xxx</strong>: <a href="https://www.npmjs.com/package/ref">ref</a> compatible OpenCL type definitions, see the complete list there: <a href="https://github.com/unbornchikken/NOOOCL/blob/master/lib/cl/types.js">NOOOCL/lib/cl/types.js</a>.</li>
</ul>
<p>Example:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> hostVersion = host.cl.version;

<span class="hljs-keyword">var</span> someOpenCLValue = host.cl.defs.CL_MEM_COPY_HOST_PTR;

<span class="hljs-keyword">var</span> err = host.cl.imports.clEnqueueNDRangeKernel(
    queue.handle,
    kernel.handle,
    <span class="hljs-number">1</span>,
    <span class="hljs-literal">null</span>,
    global.size,
    <span class="hljs-literal">null</span>,
    <span class="hljs-number">0</span>,
    <span class="hljs-literal">null</span>,
    <span class="hljs-literal">null</span>);</code></pre>
<h4 id="platforms">Platforms</h4>
<p>Then we can access to supported platforms:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> count = host.platformsCount;

<span class="hljs-comment">// we will get an array filled with instances of nooocl.CLPlatform class</span>
<span class="hljs-keyword">var</span> allPlatforms = host.getPlatforms();</code></pre>
<p>For each platform we can access its information in JS properties:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> platform = host.getPlatforms()[<span class="hljs-number">0</span>]; <span class="hljs-comment">// First platform</span>

<span class="hljs-keyword">var</span> info = {
    name: platform.name,
    vendor: platform.vendor,
    clVersion: platform.clVersion,
    profile: platform.profile,
    extensions: platform.extensions
};</code></pre>
<p>CLPlatform and all CL<em> class instances except CLHost share the </em>handle* property, which holds the value of cl_platform_id, cl_command_queue, cl_kernel, etc, OpenCL native handles.
These handles will be automatically released during garbage collection, rr they can be released explicitly by calling release method.</p>
<h4 id="devices">Devices</h4>
<p>we can query available devices:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> all = platform.allDevices();

<span class="hljs-keyword">var</span> cpus = platform.cpuDevices();

<span class="hljs-keyword">var</span> gpus = platform.gpuDevices();

<span class="hljs-keyword">var</span> accels = platform.accelDevices();

<span class="hljs-keyword">var</span> gpusAndCpus =
    platform.getDevices(
        platform.cl.defs.CL_DEVICE_TYPE_GPU |
        platform.cl.defs.CL_DEVICE_TYPE_CPU);</code></pre>
<p>we will get an array of nooocl.CLDevice class instances. CLDevice can provide all OpenCL device information in simple JavaScript properties, for example:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> cpuDevice = platform.cpuDevices()[<span class="hljs-number">0</span>];

<span class="hljs-comment">// we get the value of CL_DEVICE_MAX_COMPUTE_UNITS:</span>
<span class="hljs-keyword">var</span> maxComputeUnits = cpuDevice.maxComputeUnits;

<span class="hljs-comment">// we get the value of CL_DEVICE_MAX_WORK_ITEM_SIZES in an array like: [256, 64, 1]:</span>
<span class="hljs-keyword">var</span> maxWorkItemSizes = cpuDevice.maxWorkItemSizes;</code></pre>
<p>Please see the API docs or <a href="https://github.com/unbornchikken/NOOOCL/blob/master/tests/hostTests.js">NOOOCL/tests/hostTests.js</a> unit test for complete list of available device info properties.</p>
<p>Ok, we have a host, a platform, a device, now we need a context. we can create it from a CLDevice instance, from an array of CLDevice instances, or from a CLPlatform instance and a device type, like:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Create content for a single device:</span>
<span class="hljs-keyword">var</span> cpuDevice = platform.cpuDevices()[<span class="hljs-number">0</span>];
context = <span class="hljs-keyword">new</span> CLContext(cpuDevice);

<span class="hljs-comment">// Create context for multiple devices:</span>
<span class="hljs-keyword">var</span> gpusAndCpus =
    platform.getDevices(
        platform.cl.defs.CL_DEVICE_TYPE_GPU |
        platform.cl.defs.CL_DEVICE_TYPE_CPU);
context = <span class="hljs-keyword">new</span> CLContext(gpusAndCpus);

<span class="hljs-comment">// Create context for a platform's devices:</span>
context = <span class="hljs-keyword">new</span> CLContext(platform, platform.cl.defs.CL_DEVICE_TYPE_GPU);</code></pre>
<h4 id="the-queue">The Queue</h4>
<p>The last thing that we need in every OpenCL application is the command queue. we can create a queue for a device by calling CLCommandQueue class&#39; constructor:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// The last two parameters are optional, their defaults are false:</span>
<span class="hljs-keyword">var</span> queue = <span class="hljs-keyword">new</span> CLCommandQueue(context, cpuDevice, isOutOfOrder, isProfilingEnabled);</code></pre>
<p>CLCommandQueue implements every clEnqueue* method but names modified slightly, like: clEnqueueMarker becomes enqueueMarker, clEnqueueNDRangeKernel becomes enqueueNDRangeKernel, and so on.
Please see the API docs further details.</p>
<p>The queue has two modes. Waitable and non waitable. A queue initially is non waitable.
If the queue is non waitable its enqueue<em> methods return undefined, if waitable enqueue</em> methods return a CLEvent instance which have a <em>promise</em> property of type <a href="https://www.npmjs.com/package/bluebird">bluebird promise</a>.
we can switch modes by calling waitable method, which accepts an optional boolean parameter. When its true, the result queue will be waitable, if false, the result queue will be non waitable. Default value is true.</p>
<p>Example:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> queue = <span class="hljs-keyword">new</span> CLCommandQueue(context, device); <span class="hljs-comment">// It's non waitable.</span>

<span class="hljs-comment">// Fire and forget a kernel:</span>
queue.enqueueNDRangeKernel(kernel, <span class="hljs-keyword">new</span> NDRange(<span class="hljs-number">10</span>));

<span class="hljs-comment">// Read its result asynchronously:</span>
queue.waitable().enqueueReadBuffer(
    openCLBuffer,
    <span class="hljs-number">0</span>,
    size_in_bytes,
    destNodeJSBuffer).promise
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// Data is copied into host's destNodeJSBuffer from the device</span>
    });</code></pre>
<p>Please note <em>there is no synchronous operations in NOOOCL</em>, because those kill the event loop.</p>
<h3 id="2-memory">2. Memory</h3>
<p>NOOOCL uses <a href="http://nodejs.org/api/buffer.html">standard Node.js Buffer</a> for memory pointers. Raw memory operations, like reinterpreting are implemented by using <a href="https://www.npmjs.com/package/ref">ref and co</a>.</p>
<h4 id="allocate">Allocate</h4>
<p>OpenCL runtime can allocate memory if requested.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> openCLBuffer = <span class="hljs-keyword">new</span> CLBuffer(
    context,
    host.cl.defs.CL_MEM_ALLOC_HOST_PTR,
    size_in_bytes_here);</code></pre>
<p>we can copy data into this buffer, and copy data from it into Node.js memory.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> destBuffer = <span class="hljs-keyword">new</span> Buffer(openCLBuffer.size);
queue.waitable().enqueueReadBuffer(
    openCLBuffer,
    <span class="hljs-number">0</span>,
    openCLBuffer.size,
    destBuffer).promise
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">//destBuffer holds the data</span>

        <span class="hljs-comment">// setting some values at Node.js side</span>
        ref.types.float.set(destBuffer, <span class="hljs-number">0</span>, <span class="hljs-number">1.1</span>);
        ref.types.float.set(destBuffer, <span class="hljs-number">1</span> * ref.types.float.size, <span class="hljs-number">1.1</span>);

        <span class="hljs-comment">// copy data back to OpenCL memory:</span>
        queue.enqueueWriteBuffer(openCLBuffer, <span class="hljs-number">0</span>, openCLBuffer.size, destBuffer);
    });</code></pre>
<h4 id="copy">Copy</h4>
<p>OpenCL buffers can be initialized by copying values from an already initialized Node.js Buffer.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> float = ref.types.float;
<span class="hljs-keyword">var</span> nodeBuffer = <span class="hljs-keyword">new</span> Buffer(float.size * <span class="hljs-number">3</span>);
float.set(nodeBuffer, <span class="hljs-number">0</span>, <span class="hljs-number">1.1</span>);
float.set(nodeBuffer, float.size, <span class="hljs-number">2.2</span>);
float.set(nodeBuffer, float.size * <span class="hljs-number">2</span>, <span class="hljs-number">3.3</span>);
<span class="hljs-keyword">var</span> openCLBuffer = <span class="hljs-keyword">new</span> CLBuffer(
    context,
    host.cl.defs.CL_MEM_COPY_HOST_PTR,
    nodeBuffer.length,
    nodeBuffer);
<span class="hljs-keyword">var</span> otherBuffer = <span class="hljs-keyword">new</span> Buffer(nodeBuffer.length);
queue.waitable().enqueueReadBuffer(
    openCLBuffer,
    <span class="hljs-number">0</span>,
    openCLBuffer.
    size,
    otherBuffer).promise
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// OpenCL buffer's data are copied to otherBuffer, check;</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; otherBuffer.length; i++) {
            assert.equal(otherBuffer[i], nodeBuffer[i]);
        }
    });</code></pre>
<h4 id="use">Use</h4>
<p>OpenCL can use Node.js buffers directly. It is safe to access its content only after a mapping operation.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> float = ref.types.float;
<span class="hljs-keyword">var</span> nodeBuffer = <span class="hljs-keyword">new</span> Buffer(float.size * <span class="hljs-number">3</span>);
float.set(nodeBuffer, <span class="hljs-number">0</span>, <span class="hljs-number">1.1</span>);
float.set(nodeBuffer, float.size, <span class="hljs-number">2.2</span>);
float.set(nodeBuffer, float.size * <span class="hljs-number">2</span>, <span class="hljs-number">3.3</span>);

<span class="hljs-keyword">var</span> openCLBuffer = <span class="hljs-keyword">new</span> CLBuffer(
    context,
    host.cl.defs.CL_MEM_USE_HOST_PTR,
    nodeBuffer.length,
    nodeBuffer);

<span class="hljs-comment">// We can use the following shortcut syntax instead of the above constructor call:</span>
<span class="hljs-comment">// var openCLBuffer = CLBuffer.wrap(context, nodeBuffer);</span>

<span class="hljs-keyword">var</span> otherBuffer = <span class="hljs-keyword">new</span> Buffer(nodeBuffer.length);
<span class="hljs-keyword">var</span> out = {};
queue.enqueueMapBuffer(
    openCLBuffer,
    host.cl.defs.CL_MAP_READ | host.cl.defs.CL_MAP_WRITE,
    <span class="hljs-number">1</span> * float.size, <span class="hljs-comment">// offset</span>
    <span class="hljs-number">2</span> * float.size, <span class="hljs-comment">// size</span>
    out).promise
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// out.ptr holds the mapped ptr address of ref type void*</span>
        <span class="hljs-comment">// since we've requested the pointer from byte offset float.size,</span>
        <span class="hljs-comment">// and OpenCL uses nodeBuffer's memory as host side pointer,</span>
        <span class="hljs-comment">// then the following assertion holds:</span>
        assert.equal(
            ref.address(out.ptr),
            ref.address(nodeBuffer) + float.size);

        <span class="hljs-comment">// We should reinterpret result ptr to a usable sized buffer with ref:</span>
        <span class="hljs-keyword">var</span> mappedBuffer = ref.reinterpret(out.ptr, <span class="hljs-number">2</span> * float.size, <span class="hljs-number">1</span> * float.size);

        <span class="hljs-comment">// Now we're using the same memory for sure:</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; mappedBuffer.length; i++) {
            assert.equal(otherBuffer[i], nodeBuffer[i + float.size]);
        }

        <span class="hljs-comment">// Why out.ptr if we have access the original buffer?</span>
        <span class="hljs-comment">// That's because mapping is available for OpenCL allocated buffers as well,</span>
        <span class="hljs-comment">// if CL_MEM_ALLOC_HOST_PTR flags is used only,</span>
        <span class="hljs-comment">// or CL_MEM_USE_HOST_PTR flag is set along with CL_MEM_COPY_HOST_PTR</span>

        <span class="hljs-comment">// ...</span>

        <span class="hljs-comment">// After doing stuff, we have to unmap memory:</span>
        queue.enqueueUnmapMemory(openCLBuffer, out.ptr);
    });</code></pre>
<h4 id="images">Images</h4>
<p>2D and 3D images are also supported in NOOOCL. There is a unit test that shows how we can do OpenCL accelerated image grayscale conversion in NOOOCL,
please take a look at it there: <a href="https://github.com/unbornchikken/NOOOCL/blob/beta-dev/tests/imageTests.js">NOOOCL/tests/imageTests.js</a>.</p>
<p>Fist, we should open the image and access to its raw RGBA data in a Node.js buffer. Any appropriate npm module can be used there (I suggest <a href="https://github.com/EyalAr/lwip">lwip</a>).</p>
<p>Then we can create and OpenCL image from it:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> ImageFormat = host.conel.types.ImageFormat;
<span class="hljs-keyword">var</span> format = <span class="hljs-keyword">new</span> ImageFormat({
    imageChannelOrder: host.cl.defs.CL_RGBA,
    imageChannelDataType: host.cl.defs.CL_UNSIGNED_INT8
});

<span class="hljs-comment">// Wrap means CL_MEM_USE_HOST_PTR</span>
<span class="hljs-keyword">var</span> src = CLImage2D.wrapReadOnly(
    context,
    format,
    inputImage.width,
    inputImage.height,
    inputImage.data);</code></pre>
<p>Please refer to the API docs for further details.</p>
<h3 id="3-program">3. Program</h3>
<h4 id="build">Build</h4>
<p>OpenCL programs can be compiled from string source code or loaded from precompiled binaries, these methods are supported in NOOOCL.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Creating OpenCL program from string source:</span>
<span class="hljs-keyword">var</span> source = <span class="hljs-string">'kernel void foo(global float* data) { }'</span>;
<span class="hljs-keyword">var</span> program = context.createProgram(source);

<span class="hljs-comment">// Everything is asynchronous in Node.js:</span>
program.build(<span class="hljs-string">'-cl-fast-relaxed-math'</span>).then(
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// At this point we don't know that the build succeeded or failed.</span>
        <span class="hljs-comment">// Since one context can hold multiple devices,</span>
        <span class="hljs-comment">// and a build could succeeded on a device, but could failed on the other,</span>
        <span class="hljs-comment">// NOOOCL won't raise build errors, we should asks for it per device basis:</span>

        <span class="hljs-comment">// can be either: CL_BUILD_SUCCESS, CL_BUILD_ERROR</span>
        <span class="hljs-keyword">var</span> buildStatus = program.getBuildStatus(device);

        <span class="hljs-comment">// Compiler output:</span>
        <span class="hljs-keyword">var</span> buildLog = program.getBuildLog(device);
    });</code></pre>
<p>After a program builds we can access it&#39;s binaries for each device:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// This returns an array of CLDevice instances</span>
<span class="hljs-keyword">var</span> devices = program.devices;

<span class="hljs-comment">// This returns an array of Buffer instances</span>
<span class="hljs-keyword">var</span> binaries = program.getBinaries();

<span class="hljs-comment">// According to the OpenCL Specification:</span>
<span class="hljs-comment">// "Each entry in this array is used by the implementation</span>
<span class="hljs-comment">// as the location in memory where to copy the program binary for a specific device,</span>
<span class="hljs-comment">// if there is a binary available. To find out which device</span>
<span class="hljs-comment">// the program binary in the array refers to,</span>
<span class="hljs-comment">// use the CL_PROGRAM_DEVICES query to get the list of devices.</span>
<span class="hljs-comment">// There is a one-to-one correspondence between the array of n pointers</span>
<span class="hljs-comment">// returned by CL_PROGRAM_BINARIES and array of devices</span>
<span class="hljs-comment">// returned by CL_PROGRAM_DEVICES."</span>

<span class="hljs-comment">// So we can zip the above:</span>
<span class="hljs-keyword">var</span> deviceBinaries =
    _.zip(devices, binaries)
    .map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a)</span> </span>{ <span class="hljs-keyword">return</span> { device: a[<span class="hljs-number">0</span>], binary: a[<span class="hljs-number">1</span>] }; );</code></pre>
<p>Binaries could be stored in files for example, so when the application executes next time,
there slow build from source process won&#39;t be necessary.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Creating program from binaries:</span>

<span class="hljs-comment">// This creates a Buffer instance:</span>
<span class="hljs-keyword">var</span> binary = fs.readFileSync(<span class="hljs-string">'/tmp/foo.bin'</span>);

<span class="hljs-keyword">var</span> program = context.createProgram(binary, device);

<span class="hljs-comment">// We should call build,</span>
<span class="hljs-comment">// but this time it will be much faster than compiling from source:</span>
program.build().then(
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// can be either: CL_BUILD_SUCCESS, CL_BUILD_ERROR</span>
        <span class="hljs-keyword">var</span> buildStatus = program.getBuildStatus(device);

        <span class="hljs-comment">// Compiler output:</span>
        <span class="hljs-keyword">var</span> buildLog = program.getBuildLog(device);

        <span class="hljs-comment">// ...</span>
    });</code></pre>
<h4 id="kernel">Kernel</h4>
<p>We can create kernel by name, or can create all kernels in the program at once.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// By name:</span>
doStuffKernel = program.createKernel(<span class="hljs-string">'doStuff'</span>);

<span class="hljs-comment">// All. This time the return values is an array of CLKernel instances.</span>
<span class="hljs-keyword">var</span> kernels = program.createAllKernels();
doStuffKernel = _.first(_.where(kernels, { name: <span class="hljs-string">'doStuff'</span> }));</code></pre>
<p>We can set its arguments by index, or all at once:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Assume we have a kernel of the following signature:</span>
<span class="hljs-comment">// kernel void doStuff(global float* data, uint someValue, local float* tmp) {...}</span>
<span class="hljs-comment">// and a CLBuffer instance created like:</span>
<span class="hljs-comment">// var openCLBuffer = CLBuffer.wrap(context, nodeBuffer);</span>


<span class="hljs-keyword">var</span> kernel = program.createKernel(<span class="hljs-string">'doStuff'</span>);

<span class="hljs-comment">// We can set kernel's arguments by index:</span>

<span class="hljs-comment">// For buffer arguments we can pass the instance of a CLBuffer class:</span>
kernel.setArg(<span class="hljs-number">0</span>, openCLBuffer);
<span class="hljs-comment">// or native cl_mem handle</span>
<span class="hljs-comment">// kernel.setArg(0, openCLBuffer.handle);</span>

<span class="hljs-comment">// For constant arguments we have to specify its type</span>
kernel.setArg(<span class="hljs-number">1</span>, <span class="hljs-number">55</span>, <span class="hljs-string">'uint'</span>);

<span class="hljs-comment">// For local buffers, we have to specify its size in bytes</span>
kernel.setArg(<span class="hljs-number">2</span>, <span class="hljs-number">100</span> * float.size);

<span class="hljs-comment">// Or we can specify all of the arguments at once:</span>

kernel.setArgs(openCLBuffer, {<span class="hljs-string">'uint'</span>: <span class="hljs-number">55</span>}, <span class="hljs-number">100</span> * float.size);</code></pre>
<p>Now we can enqueue the kernel. In NOOOCL there is an NDRange class, for defining OpenCL ranges.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// 1 dimension range:</span>
<span class="hljs-keyword">var</span> r1 = <span class="hljs-keyword">new</span> NDRange(<span class="hljs-number">10</span>);

<span class="hljs-comment">// 2 dimensions range:</span>
<span class="hljs-keyword">var</span> r2 = <span class="hljs-keyword">new</span> NDRange(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);

<span class="hljs-comment">// 3 dimensions range</span>
<span class="hljs-keyword">var</span> r3 = <span class="hljs-keyword">new</span> NDRange(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>);</code></pre>
<p>So the enqueuing is really simple:</p>
<pre><code class="lang-javascript">queue.enqueueNDRangeKernel(
    kernel,
    <span class="hljs-keyword">new</span> NDRange(<span class="hljs-number">3</span>), <span class="hljs-comment">// global size</span>
    <span class="hljs-literal">null</span>, <span class="hljs-comment">// local size</span>
    <span class="hljs-keyword">new</span> NDRange(<span class="hljs-number">1</span>) <span class="hljs-comment">// offset</span>
);</code></pre>
<p>We can create a simple JavaScript function for calling OpenCL kernels with ad-hoc arguments by using the bind method:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> func = kernel.bind(
    queue, <span class="hljs-comment">// command queue to use</span>
    <span class="hljs-keyword">new</span> NDRange(<span class="hljs-number">3</span>), <span class="hljs-comment">// global size</span>
    <span class="hljs-literal">null</span>, <span class="hljs-comment">// local size</span>
    <span class="hljs-keyword">new</span> NDRange(<span class="hljs-number">1</span>)); <span class="hljs-comment">// offset</span>

<span class="hljs-comment">// Now we have a JS function to call (aka set arguments and enqueue)</span>
<span class="hljs-comment">// our OpenCL kernel!</span>
<span class="hljs-comment">// It's easy as goblin pie.</span>
func(openCLBuffer, {<span class="hljs-string">'uint'</span>: <span class="hljs-number">55</span>}, <span class="hljs-number">100</span> * float.size);</code></pre>
<h3 id="4-api">4. API</h3>
<p>In progress. (Groc&#39;s gonna be used.)</p>
<h3 id="5-examples">5. Examples</h3>
<p>TODO (I&#39;m gonna try to make some particle simulation demo in node-webkit)</p></div></div></div></div></body></html>